//
// Open Controls - MDL to C++ Converter
//
// Copyright (C) 2026 Daher Alfawares
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//

#include "../libmdl/oc_mdl.hpp"
#include "../libmdl/oc_codegen.hpp"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <print>

namespace fs = std::filesystem;

namespace {

    void print_usage(std::string_view program) {
        std::println("Usage: {} <input.mdl> [subsystem_filter]", program);
        std::println("");
        std::println("Converts Simulink MDL subsystems to C++ code.");
        std::println("Output directory: <model_name>-cpp/");
    }

    [[nodiscard]] auto to_lowercase(std::string_view str) -> std::string {
        std::string result;
        result.reserve(str.size());
        std::ranges::transform(str, std::back_inserter(result),
            [](unsigned char c) { return static_cast<char>(std::tolower(c)); });
        return result;
    }

    [[nodiscard]] auto sanitize_filename(std::string_view name) -> std::string {
        std::string result;
        for (char c : name) {
            if (std::isalnum(static_cast<unsigned char>(c)) || c == '_' || c == '-') {
                result += c;
            } else if (c == ' ') {
                result += '_';
            }
        }
        return result;
    }

} // namespace

auto main(int argc, char* argv[]) -> int {
    if (argc < 2) {
        print_usage(argv[0]);
        return 1;
    }

    std::string input_file;
    std::string filter;

    for (int i = 1; i < argc; ++i) {
        std::string_view arg = argv[i];
        if (arg == "-h" || arg == "--help") {
            print_usage(argv[0]);
            return 0;
        } else if (input_file.empty()) {
            input_file = std::string(arg);
        } else {
            filter = std::string(arg);
        }
    }

    if (input_file.empty()) {
        std::println(stderr, "Error: No input file specified");
        return 1;
    }

    fs::path input_path(input_file);
    auto model_name = input_path.stem().string();
    auto output_dir = model_name + "-cpp";

    std::println("Loading MDL file: {}", input_file);

    oc::mdl::parser parser;
    if (!parser.load(input_file)) {
        std::println(stderr, "Error: Failed to parse MDL file");
        return 1;
    }

    const auto& model = parser.get_model();
    std::println("Systems: {}", model.systems.size());

    fs::create_directories(output_dir);

    const auto* root = model.root_system();
    if (!root) {
        std::println(stderr, "Error: No root system found");
        return 1;
    }

    auto library_name = to_lowercase(model_name);
    if (library_name.size() > 4 && library_name.ends_with("_lib")) {
        library_name = library_name.substr(0, library_name.size() - 4);
    }

    oc::codegen::generator codegen;
    codegen.set_model(&model);

    int exported = 0;

    std::println("\nGenerating C++ code...");

    for (const auto& blk : root->subsystems()) {
        if (blk.subsystem_ref.empty()) continue;

        // Apply filter if specified
        if (!filter.empty() && blk.name.find(filter) == std::string::npos) continue;

        const auto* subsys = model.get_system(blk.subsystem_ref);
        if (!subsys) continue;

        oc::mdl::system named_sys = *subsys;
        named_sys.name = blk.name;

        auto base_filename = sanitize_filename(blk.name);
        auto cpp_content = codegen.generate(named_sys, library_name);

        // Add header
        std::ostringstream out;
        out << "//\n";
        out << "// Generated from: " << input_file << "\n";
        out << "// Subsystem: " << blk.name << "\n";
        out << "//\n";
        out << "// This file was auto-generated by mdl_to_cpp.\n";
        out << "// Manual edits may be overwritten.\n";
        out << "//\n\n";
        out << "#pragma once\n\n";
        out << "#include <algorithm>\n";
        out << "#include <cmath>\n\n";
        out << cpp_content;

        auto filename = base_filename + ".hpp";
        auto filepath = fs::path(output_dir) / filename;

        if (std::ofstream file(filepath); file) {
            file << out.str();
            ++exported;
            std::println("  {} -> {}", blk.name, filename);
        } else {
            std::println(stderr, "  Error: Could not write {}", filepath.string());
        }
    }

    std::println("\nGenerated {} C++ file(s) in {}/", exported, output_dir);

    return 0;
}
